#include "avdweb_AnalogReadFast.h"

#define BUFFER 500    // кол-во точек для записи


byte val_1[BUFFER] = {0};   // массив для хранения считанных данных КАНАЛ 1
byte val_2[BUFFER] = {0};   // массив для хранения считанных данных КАНАЛ 2
unsigned int i = 0;         // для подсчета точек

void setup() {
  Serial.begin(115200);   // скорость UART
 
  // инициализация Timer1
  cli();                  // отключить глобальные прерывания
  TCCR1A = 0;             // обнулить счетные регистры
  TCCR1B = 0; 

  OCR1A = 11;             // установка регистра совпадения (249 - 1мс, 24 - 100мкс, 11 - 48 мкс)
  TCCR1B |= (1 << WGM12); // включение в CTC режим

  // Установка битов CS10 и CS12 на коэффициент деления 64 (1 тик - 4мкс)
  TCCR1B |= (1 << CS10);
  TCCR1B |= (1 << CS11);
  //TCCR1B |= (1 << CS12);

  TIMSK1 |= (1 << OCIE1A);  // включение прерываний по совпадению
  sei();                    // включить глобальные прерывания
}

void loop() {
  // ожидаем заполнения буфера
  if (i == BUFFER){
    TIMSK1 &= ~(1 << OCIE1A); // выключение прерываний по совпадению
    for(int j = 0; j < BUFFER; j++) {
      Serial.write(val_1[j]);   // отправить массив данных КАНАЛ 1
    }
    Serial.write(1);Serial.write(128);Serial.write(254);   // разделитель данных
    for(int j = 0; j < BUFFER; j++) {
      Serial.write(val_2[j]);   // отправить массив данных КАНАЛ 2
    }
    Serial.write(2);Serial.write(128);Serial.write(254);   // разделитель данных
    i = 0;    // сброс счетчика битов
    Serial.flush();   // ожидаем отправку всех данных
    delay(300);       // для более понятного отображения данных на графике, при необходимости можно убрать
    TIMSK1 |= (1 << OCIE1A);  // включение прерываний по совпадению
  }
}

  // обработка прерывания по таймеру
ISR(TIMER1_COMPA_vect)
{
  val_1[i] = analogReadFast(A1) >> 2;   // считываем данные с АЦП КАНАЛ 1
  val_2[i] = analogReadFast(A2) >> 2;   // считываем данные с АЦП КАНАЛ 2
  i++;    // прибавляем счетчик
}
