#include "avdweb_AnalogReadFast.h"

#define BUFFER 1500    // кол-во точек для записи


byte val[BUFFER] = {0};   // массив для хранения считанных данных
unsigned int i = 0;       // для подсчета точек


void setup() {
  Serial.begin(115200);   // скорость UART
 
  // инициализация Timer1
  cli();                  // отключить глобальные прерывания
  TCCR1A = 0;             // обнулить счетные регистры
  TCCR1B = 0; 

  OCR1A = 24;             // установка регистра совпадения (249 - 1мс, 24 - 100мкс, 11 - 48 мкс)
  TCCR1B |= (1 << WGM12); // включение в CTC режим

  // Установка битов CS10 и CS12 на коэффициент деления 64 (1 тик - 4мкс)
  TCCR1B |= (1 << CS10);
  TCCR1B |= (1 << CS11);
  //TCCR1B |= (1 << CS12);

  TIMSK1 |= (1 << OCIE1A);  // включение прерываний по совпадению
  sei();                    // включить глобальные прерывания
}

void loop() {
  // ожидаем заполнения буфера
  if (i == BUFFER){
    TIMSK1 &= ~(1 << OCIE1A); // выключение прерываний по совпадению
    for(int j = 0; j < BUFFER; j++) {
      Serial.write(val[j]);   // отправить массив данных
    }
    Serial.write(1);Serial.write(128);Serial.write(254);   // разделитель данных
    i = 0;    // сброс счетчика битов
    Serial.flush();   // ожидаем отправку всех данных
         // для более понятного отображения данных на графике, при необходимости можно убрать
    TIMSK1 |= (1 << OCIE1A);  // включение прерываний по совпадению
  }
}
    
  // обработка прерывания по таймеру
ISR(TIMER1_COMPA_vect)
{
  val[i] = analogReadFast(A0) >> 1 ;   // считываем данные с АЦП
  Serial.println(val[i]);
  i++;    // прибавляем счетчик
}
